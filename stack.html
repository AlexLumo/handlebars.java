---
layout: default
title: The Mustache Context Stack in Handlebars.java
version: 1.0.0
---

<div>
  <h1>The {{ "{{ Mustache " }}}} Context Stack in Handlebars.java</h1>
</div>
<p>
In this section you will learn how to interact with the Context Stack in <a href="https://github.com/jknack/handlebars.java">Handlebars.java</a>.
</p>

<h2>The Context Stack</h2>
<a href="http://mustache.github.com/mustache.5.html">Mustache</a> is a contextual and stack based template engine. The context stack is where the your data live.
<p>
The <a href="https://github.com/jknack/handlebars.java/blob/master/handlebars/src/main/java/com/github/jknack/handlebars/Context.java">Context</a> class represent the <strong>context stack</strong> in <a href="https://github.com/jknack/handlebars.java">Handlebars.java</a>.
You rarely need to instantiate a<code>Context</code>object, bc <a href="https://github.com/jknack/handlebars.java">Handlebars.java</a> does it for you
every time you call:
</p>

<div class="highlight">
<pre>
  String output = template.apply(model);
  <span class="nf">// or</span>
  template.apply(model, writer);
</pre>
</div>
<p>
The<code>apply</code>method accepts a<code>Context</code> or an<code>Object</code>. The<code>apply(Object)</code>function, automatically convert the object into a<code>Context</code>. 
</p>

<h2>Resolving values</h2>

<div class="highlight">
The resolution algorithm looks something like:
<pre>
  <span class="nt">while</span> (context != null && context.get(<span class="s2">"value"</span>) == null) {
    context = context.parent;
  }
</pre>
</div>

<p>
A <strong>value</strong> will be resolved in the <strong>current context</strong>.
</p>
<p>
If the value isn't here, the <strong>parent context</strong> need to resolved the value.
</p>
<p>
If the value isn't in the whole stack, the value is resolved to <strong>null</strong> and nothing will be rendered.
</p>

<h2>Extending the context stack</h2>
<p>
  A common use case in web applications is to access to the logged user from a web page.
</p>

<div class="highlight">
A first try might looks like:
<pre>
  User user = ...;
  Object model = ...;
  Map modelWithUser = new HashMap();
  modelWithUser.put(<span class="s2">"user"</span>, user);
  modelWithUser.put(<span class="s2">"model"</span>, model);

  template.apply(modelWithUser);
</pre>
</div>
<p>This isn't so bad but there are at least two drawbacks:</p>
<ol>
  <li>You will need to write or add this snippet of code in every single page that want access to the current logged user.</li>
  <li>You are force to access to your data using the {{ "{{#model" }}}}...{{ "{{/model" }}}} expression.</li>
</ol>

<div class="highlight">
A better approach is to use the<code>combine</code>method:
<pre>
  User user = ...;
  Object model = ...;
  Context context = Context
    .newBuilder(model)
    .combine("user", user)
    .build();

  template.apply(context);
</pre>
</div>

<p>
We definitely fix the <strong>second</strong> drawback described before.
</p>
<p>
The <strong>first</strong> one depends on your application architecture. For example,
if you have a<code>hook</code>method where you can globally merge the model with a view
(and of course you can access to the current logged user).
</p>

<h2 id="resolvers">Value resolvers</h2>
<p>
A<code>ValueResolver</code>is responsible of extracting a single value from a source object.
By default, only <code>maps</code>and<code>JavaBean</code>objects are supported.
</p>

<h3>The JavaBeanValueResolver</h3>
<p>
Let you access to JavaBean properties. It is registered by <strong>default</strong>.
</p>

<div class="highlight">
<pre>
  Context context = Context
    .newBuilder(model)
    .resolver(JavaBeanValueResolver.<span class="nt">INSTANCE</span>)
    .build();

  template.apply(context);
</pre>
</div>

<h3>The MapValueResolver</h3>
<p>
Let you access to<code>map</code>values. It is registered by <strong>default</strong>.
</p>

<div class="highlight">
<pre>
  Context context = Context
    .newBuilder(model)
    .resolver(MapValueResolver.<span class="nt">INSTANCE</span>)
    .build();

  template.apply(context);
</pre>
</div>

<h3>The FieldValueResolver</h3>
<p>
Let you access to instance fields (private or public).
</p>

<div class="highlight">
<pre>
  Context context = Context
    .newBuilder(model)
    .resolver(FieldValueResolver.<span class="nt">INSTANCE</span>)
    .build();

  template.apply(context);
</pre>
</div>

<h3>The MethodValueResolver</h3>
<p>
Let you access to public methods.
</p>

<div class="highlight">
<pre>
  Context context = Context
    .newBuilder(model)
    .resolver(MethodValueResolver.<span class="nt">INSTANCE</span>)
    .build();

  template.apply(context);
</pre>
</div>

<h3>Using multiples value resolvers</h3>
<p>
You can combine any number of value resolvers according to your application data.
</p>

<div class="highlight">
Access to JavaBean and Map properties:
<pre>
  Context context = Context
    .newBuilder(model)
    .resolver(
        MapValueResolver.<span class="nt">INSTANCE</span>,
        JavaBeanValueResolver.<span class="nt">INSTANCE</span>
    )
    .build();

  template.apply(context);
</pre>
</div>

<div class="highlight">
Access to JavaBean, Map properties and public methods:
<pre>
  Context context = Context
    .newBuilder(model)
    .resolver(
        MapValueResolver.<span class="nt">INSTANCE</span>,
        JavaBeanValueResolver.<span class="nt">INSTANCE</span>,
        MethodValueResolver.<span class="nt">INSTANCE</span>
    )
    .build();

  template.apply(context);
</pre>
</div>

<div class="highlight">
Access to JavaBean, Map properties and instance fields:
<pre>
  Context context = Context
    .newBuilder(model)
    .resolver(
        MapValueResolver.<span class="nt">INSTANCE</span>,
        JavaBeanValueResolver.<span class="nt">INSTANCE</span>,
        FieldValueResolver.<span class="nt">INSTANCE</span>
    )
    .build();

  template.apply(context);
</pre>
</div>

<h1>Conclusion</h1>
<p>The<code>Context</code>class does all the hard work: walk through the stack, resolve expressions, etc. This component isn't puggable and can't be set.</p>
<p>
Where a<code>ValueResolver</code>extracts a single value from a source. You can add, remove or even create your own <code>value resolver</code>.
It plays an important role if your application deal with a custom data source.</p>
<p>For example,
if your service layer returns the widely used<code>JsonNode</code>from
<a href="http://jackson.codehaus.org/">Jackson</a> a custom <a href="https://github.com/jknack/handlebars.java/blob/master/handlebars/src/main/java/com/github/jknack/handlebars/Context.java">ValueResolver</a> can access
to that object and extract values from it.
</p>
